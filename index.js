// Generated by CoffeeScript 1.9.0
(function() {
  var co, escodegen, esprima, instapromise, optimist, pkg, vm;

  exports.__doc__ = "A plugin for nesh that lets you yield async values in the REPL\n\nIf you do normal REPL things, everything should work the same as before.\nBut if you type `yield` into the REPL, then this plugin will cause that\nline to be evaluated wrapped by co, so you can get the value back\nsynchronously.\n\nWe use esprima to parse the input to tell the difference between regular\ninputs that don't need to be transformed and those that do, and we will\nalso rewrite the `yield` cases that we wrap in a function to include a\nreturn at the end if you end with an ExpressionStatement so that you\ndon't have to type `return yield` all the time to get values back!\n\nThis plugin also does a few other things for your convenience.\n- It changes the prompt to have a * in it so you know its enabled\n- It includes instapromise so you can do work easily with traditional\n  Node-style async functions that use callbacks\n- It puts a custom `util.log` inspect function in place on Promises\n  so that they show up as something more useful than '{}'\n";

  co = require('co');

  escodegen = require('escodegen');

  esprima = require('esprima-fb');

  optimist = require('optimist');

  vm = require('vm');

  pkg = require('./package');

  instapromise = require('instapromise');

  optimist.describe(['y', 'co'], "Use co so you can yield async values, etc.");

  if ((optimist.argv.co != null) || (optimist.argv.y != null)) {
    exports.setup = function(context) {
      var nesh, _promiseObjectSequenceId;
      nesh = context.nesh;
      process.versions.nesh_co = pkg.version;
      try {
        process.versions.co = require(require.resolve('co').replace('index.js', 'package.json')).version;
      } catch (_error) {
        process.versions.co = '?';
      }
      nesh.defaults.prompt = nesh.defaults.prompt.replace('> ', '*> ');
      if (Promise.prototype.inspect == null) {
        _promiseObjectSequenceId = 0;
        return Promise.prototype.inspect = function(depth) {
          "A custom `util.format` for Promises";
          if (this.___inspect_promiseObjectSequenceId___ == null) {
            this.___inspect_promiseObjectSequenceId___ = _promiseObjectSequenceId++;
          }
          return "[Promise #" + this.___inspect_promiseObjectSequenceId___ + "]";
        };
      }
    };
    exports.postStart = function(context) {
      var originalEval, repl;
      repl = context.repl;
      originalEval = repl["eval"];
      return repl["eval"] = function(input, context, filename, callback) {
        var ast, body, last, result, useCo, wrapped;
        useCo = false;
        if (input.indexOf('yield') !== -1) {
          try {
            esprima.parse(input);
            useCo = false;
          } catch (_error) {
            try {
              wrapped = "(function* () { " + (input.trim()) + "; })";
              ast = esprima.parse(wrapped);
              body = ast.body[0].expression.body.body;
              last = body[body.length - 1];
              if (last.type === 'ExpressionStatement') {
                body[body.length - 1] = {
                  type: 'ReturnStatement',
                  argument: last.expression
                };
                wrapped = escodegen.generate(ast);
              }
              useCo = true;
            } catch (_error) {
              useCo = false;
            }
          }
        }
        if (useCo) {
          if (repl.useGlobal) {
            result = vm.runInThisContext(wrapped);
          } else {
            result = vm.runInContext(wrapped, context);
          }
          return co.wrap(result)().then(function(result) {
            var tmpName;
            tmpName = "$___nesh_co_result" + (Math.random().toString().substring(2)) + "___$";
            context[tmpName] = result;
            return originalEval(tmpName, context, filename, function(err, result) {
              delete context[tmpName];
              return callback(err, result);
            });
          }, function(err) {
            return callback(err);
          });
        } else {
          return originalEval(input, context, filename, callback);
        }
      };
    };
  }

}).call(this);
